/*

This locks pieces together by rotating the key a quarter turn after insertion. 

If desire, the keyhole can compress the key upon turning. 

Usage:

    use <ScadApotheka/quarter_turn_clamping_connector.scad>


dimensions = qtcc_dimensions(x, y, z, x_clearance, y_clearance, z_clearance, x_neck, x_slot, dx_squeeze[, aspect_ratio_tuning=1])   
      
quarter_turn_clamping_connector_key(core_length,  dimensions_1, dimensions_2)     

quarter_turn_clamping_connector_keyhole(dimensions, print_from_key_opening = false, bridging_diameter=0) 



The following functions allow you to access components of the dimensions:

extent = gtcc_extent(dimensions);
x = extent.x;
y = extent.y
z = extent.z

clearances =  gtcc_clearances(dimensions); 
x_clearance = clearances.x
y_clearance = clearances.y
z_clearance = 

x_neck = gtcc_x_neck(dimensions);
x_slot =  gtcc_x_slot(dimensions);
dx_sqeeze =  gtcc_dx_sqeeze(dimensions);
aspect_ratio_tuning =  gtcc_aspect_ratio_tuning(dimensions);
cam =  gtcc_cam(dimensions);
semi_major_ = cam.x


The cam itself is elliptical in shape and can be generated by using this module:

gtcc_cam_shape(cam, z_cam); 

*/

include <ScadStoicheia/centerable.scad>
use <ScadStoicheia/visualization.scad>
include <ScadApotheka/material_colors.scad>


a_lot = 100 + 0;

module end_of_customization() { }
    
 // Start of general implementation

function qtcc_dimensions(x, y, z, x_clearance, y_clearance, z_clearance, x_neck, x_slot, dx_squeeze, aspect_ratio_tuning=1) =
    let(
        s_open = x + 2*x_clearance,
        s_closed = x - dx_squeeze,
        key_width = y,
        cam = qtcc_calculate_cam_dimensions(s_open, s_closed, key_width, aspect_ratio_tuning)
    ) 
    [
    [x, y, z], 
    [x_clearance, y_clearance, z_clearance],
    x_neck, 
    x_slot, 
    dx_squeeze,
    aspect_ratio_tuning,
    cam,
];

function gtcc_extent(dimensions) = is_undef(dimensions) ? [0, 0, 0] : dimensions[0];
function gtcc_clearances(dimensions) = is_undef(dimensions) ? [0, 0, 0] : dimensions[1];
function gtcc_x_neck(dimensions) = is_undef(dimensions) ? 0 : dimensions[2];
function gtcc_x_slot(dimensions)  = is_undef(dimensions) ? 0 : dimensions[3];
function gtcc_dx_sqeeze(dimensions)  = is_undef(dimensions) ? 0 : dimensions[4];
function gtcc_aspect_ratio_tuning(dimensions)  = is_undef(dimensions) ? 0 : dimensions[5];
function gtcc_cam(dimensions)  = is_undef(dimensions) ? [0, 0] : dimensions[6];

function qtcc_calculate_cam_dimensions (s_open, s_closed, key_width, aspect_ratio_tuning) = 
  let(
    radius_open = sqrt(s_open * s_open + key_width * key_width),
    aspect_ratio = aspect_ratio_tuning * s_closed / s_open,
    iar = 1/aspect_ratio,
    x_0 = s_open / 2,
    y_0 = key_width / 2,
    // Major axis half length:
    x_cam = sqrt(x_0^2  + (iar^2*y_0^2)),
    // Minor axis half length: 
    y_cam = x_cam*aspect_ratio
  )
  [x_cam, y_cam];


module gtcc_cam_shape(cam, z) {
    scale([cam.x, cam.y, z]) {
        cylinder(h = 1, r = 1, center=true, $fn=30);
    }
}


module quarter_turn_clamping_connector_key(core_length,  dimensions_1, dimensions_2) {
    assert(is_num(core_length));
    assert(is_list(dimensions_1));
    extent_1 = gtcc_extent(dimensions_1);
    extent_2 = gtcc_extent(dimensions_2);
    x_neck_1 = gtcc_x_neck(dimensions_1);
    x_neck_2 =  gtcc_x_neck(dimensions_2);    

    // Origin is at center of first dimension pyramids
    module key_shape(dimensions) {
        extent = gtcc_extent(dimensions);
        x_neck = gtcc_x_neck(dimensions);
        x_slot  = gtcc_x_slot(dimensions); 

        base_profile = [extent.x, extent.y, 0.1];
        neck_profile = [x_neck, extent.y, 0.1];
        render(convexity = 10) difference() {
            hull() {
                block(base_profile, center=ABOVE);
                translate([0, 0, extent.z]) block(neck_profile, center=BELOW);
            }
            if (x_slot > 0) {
                block([x_slot, a_lot, a_lot]);
            }
        }
    }
    
    module core_shape() {
        core = [max(x_neck_1, x_neck_2), max(extent_1.y, extent_2.y), core_length];
        translate([0, 0, extent_1.z]) block(core, center=ABOVE);
    }
    
    key_shape(dimensions_1);
    core_shape();
    if (is_list(dimensions_2)) {    
        translate([0, 0, extent_1.z + extent_2.z + core_length]) rotate([180, 0, 0]) key_shape(dimensions_2);
    } 
}


module quarter_turn_clamping_connector_keyhole(dimensions, print_from_key_opening = false, bridging_diameter=0) {
    extent = gtcc_extent(dimensions);
    clearances = gtcc_clearances(dimensions);
    x_neck =  gtcc_x_neck(dimensions);
    dx_squeeze = gtcc_dx_sqeeze(dimensions);
    aspect_ratio_tuning = gtcc_aspect_ratio_tuning(dimensions);
    cam = gtcc_cam(dimensions);
    

    module key_insertion_clearance() {
        // Opening for key
        translate([0, 0, -clearances.x]) block(extent + 2 * clearances,  center=ABOVE);
        if (print_from_key_opening) {
            // Add bridging for opening
            s_opening = bridging_diameter == 0 ? extent.y : bridging_diameter;
            layer = 0.5; 
            first_bridging_cavity = [s_opening, 2*cam.y, 2*layer];
            translate([0, 0, extent.z+clearances.z]) block(first_bridging_cavity, center=ABOVE);
            second_bridging_cavity = [s_opening, s_opening, 2*layer];
            translate([0, 0, extent.z+clearances.z + layer]) block(second_bridging_cavity, center=ABOVE);
        }
    }
    module base_profile() {
        translate([0, 0, extent.z]) gtcc_cam_shape(cam, clearances.z);
    }
    module neck_profile() {
        d_neck = sqrt((x_neck + 2 * clearances.x)^2 + (extent.y + 2 * clearances.y)^2);
         can(d = d_neck, h = clearances.z, center=BELOW);
    }
    module rotation_clearance() {
        hull() {
           base_profile();
           neck_profile();
        }        
    }
    module cavity() {
       key_insertion_clearance();
        rotation_clearance();
    }
    module quarter_turn_stops() {
        stop_offset = extent.y/2 + clearances.y;
        translate([-stop_offset , stop_offset, -0.5])  
            block(extent + [0, 0, 1], center=ABOVE+BEHIND+RIGHT);
        translate([stop_offset , -stop_offset, -0.5])  
            block(extent + [0, 0, 1], center=ABOVE+FRONT+LEFT);
    }
  
    render(convexity = 10) difference() {
        cavity();
        quarter_turn_stops();
    }
   
}

